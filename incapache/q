SENDFILE(2)                                                     Linux Programmer's Manual                                                     SENDFILE(2)

NNAAMMEE
       sendfile - transfer data between file descriptors

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ssyyss//sseennddffiillee..hh>>

       ssssiizzee__tt sseennddffiillee((iinntt _o_u_t___f_d,, iinntt _i_n___f_d,, ooffff__tt **_o_f_f_s_e_t,, ssiizzee__tt _c_o_u_n_t));;

DDEESSCCRRIIPPTTIIOONN
       sseennddffiillee() copies data between one file descriptor and another.  Because this copying is done within the kernel, sseennddffiillee() is more efficient than
       the combination of rreeaadd(2) and wwrriittee(2), which would require transferring data to and from user space.

       _i_n___f_d should be a file descriptor opened for reading and _o_u_t___f_d should be a descriptor opened for writing.

       If _o_f_f_s_e_t is not NULL, then it points to a variable holding the file offset from which sseennddffiillee() will start reading data from _i_n___f_d.  When  sseenndd‐‐
       ffiillee() returns, this variable will be set to the offset of the byte following the last byte that was read.  If _o_f_f_s_e_t is not NULL, then sseennddffiillee()
       does not modify the file offset of _i_n___f_d; otherwise the file offset is adjusted to reflect the number of bytes read from _i_n___f_d.

       If _o_f_f_s_e_t is NULL, then data will be read from _i_n___f_d starting at the file offset, and the file offset will be updated by the call.

       _c_o_u_n_t is the number of bytes to copy between the file descriptors.

       The _i_n___f_d argument must correspond to a file which supports mmmmaapp(2)-like operations (i.e., it cannot be a socket).

       In Linux kernels before 2.6.33, _o_u_t___f_d must refer to a socket.  Since Linux 2.6.33 it can be any file.  If it is a regular file,  then  sseennddffiillee()
       changes the file offset appropriately.

RREETTUURRNN VVAALLUUEE
       If  the  transfer  was  successful,  the number of bytes written to _o_u_t___f_d is returned.  Note that a successful call to sseennddffiillee() may write fewer
       bytes than requested; the caller should be prepared to retry the call if there were unsent bytes.  See also NOTES.

       On error, -1 is returned, and _e_r_r_n_o is set appropriately.

EERRRROORRSS
       EEAAGGAAIINN Nonblocking I/O has been selected using OO__NNOONNBBLLOOCCKK and the write would block.

       EEBBAADDFF  The input file was not opened for reading or the output file was not opened for writing.

       EEFFAAUULLTT Bad address.

       EEIINNVVAALL Descriptor is not valid or locked, or an mmmmaapp(2)-like operation is not available for _i_n___f_d, or _c_o_u_n_t is negative.

       EEIINNVVAALL _o_u_t___f_d has the OO__AAPPPPEENNDD flag set.  This is not currently supported by sseennddffiillee().

       EEIIOO    Unspecified error while reading from _i_n___f_d.

       EENNOOMMEEMM Insufficient memory to read from _i_n___f_d.

       EEOOVVEERRFFLLOOWW
              _c_o_u_n_t is too large, the operation would result in exceeding the maximum size of either the input file or the output file.

       EESSPPIIPPEE _o_f_f_s_e_t is not NULL but the input file is not seekable.

VVEERRSSIIOONNSS
       sseennddffiillee() first appeared in Linux 2.2.  The include file _<_s_y_s_/_s_e_n_d_f_i_l_e_._h_> is present since glibc 2.1.

CCOONNFFOORRMMIINNGG TTOO
       Not specified in POSIX.1-2001, nor in other standards.

       Other UNIX systems implement sseennddffiillee() with different semantics and prototypes.  It should not be used in portable programs.

NNOOTTEESS
       sseennddffiillee() will transfer at most 0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually transferred.   (This  is  true  on  both
       32-bit and 64-bit systems.)

       If you plan to use sseennddffiillee() for sending files to a TCP socket, but need to send some header data in front of the file contents, you will find it
       useful to employ the TTCCPP__CCOORRKK option, described in ttccpp(7), to minimize the number of packets and to tune performance.

       In Linux 2.4 and earlier, _o_u_t___f_d could also refer to a regular file; this possibility went away in the Linux 2.6.x kernel series, but was restored
       in Linux 2.6.33.

       The original Linux sseennddffiillee() system call was not designed to handle large file offsets.  Consequently, Linux 2.4 added sseennddffiillee6644(), with a wider
       type for the _o_f_f_s_e_t argument.  The glibc sseennddffiillee() wrapper function transparently deals with the kernel differences.

       Applications may wish to fall back to rreeaadd(2)/wwrriittee(2) in the case where sseennddffiillee() fails with EEIINNVVAALL or EENNOOSSYYSS.

       If _o_u_t___f_d refers to a socket or pipe with zero-copy support, callers must ensure the transferred portions of the file referred to by _i_n___f_d  remain
       unmodified until the reader on the other end of _o_u_t___f_d has consumed the transferred data.

       The Linux-specific sspplliiccee(2) call supports transferring data between arbitrary file descriptors provided one (or both) of them is a pipe.

SSEEEE AALLSSOO
       ccooppyy__ffiillee__rraannggee(2), mmmmaapp(2), ooppeenn(2), ssoocckkeett(2), sspplliiccee(2)

CCOOLLOOPPHHOONN
       This  page is part of release 5.10 of the Linux _m_a_n_-_p_a_g_e_s project.  A description of the project, information about reporting bugs, and the latest
       version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                                   2017-09-15                                                            SENDFILE(2)
